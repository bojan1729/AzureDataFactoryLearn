{
	"$schema": "http://schema.management.azure.com/schemas/2015-01-01/deploymentTemplate.json#",
	"contentVersion": "1.0.0.0",
	"parameters": {
		"factoryName": {
			"type": "string",
			"metadata": "Data Factory name",
			"defaultValue": "bajlecadf"
		}
	},
	"variables": {
		"factoryId": "[concat('Microsoft.DataFactory/factories/', parameters('factoryName'))]"
	},
	"resources": [
		{
			"name": "[concat(parameters('factoryName'), '/test_restapi_param')]",
			"type": "Microsoft.DataFactory/factories/pipelines",
			"apiVersion": "2018-06-01",
			"properties": {
				"activities": [
					{
						"name": "Copy data from REST API to BLOB",
						"type": "Copy",
						"dependsOn": [],
						"policy": {
							"timeout": "7.00:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"source": {
								"type": "RestSource",
								"httpRequestTimeout": "00:01:40",
								"requestInterval": "00.00:00:00.010",
								"requestMethod": "GET"
							},
							"sink": {
								"type": "JsonSink",
								"storeSettings": {
									"type": "AzureBlobStorageWriteSettings"
								},
								"formatSettings": {
									"type": "JsonWriteSettings"
								}
							},
							"enableStaging": false
						},
						"inputs": [
							{
								"referenceName": "test_restapi_source_param",
								"type": "DatasetReference",
								"parameters": {
									"dssrc_fname": {
										"value": "@pipeline().parameters.pl_fname",
										"type": "Expression"
									}
								}
							}
						],
						"outputs": [
							{
								"referenceName": "test_restapi_blob_json_param",
								"type": "DatasetReference",
								"parameters": {
									"ds_fname": {
										"value": "@pipeline().parameters.pl_fname",
										"type": "Expression"
									}
								}
							}
						]
					},
					{
						"name": "Lookup JSON",
						"type": "Lookup",
						"dependsOn": [
							{
								"activity": "Copy data from REST API to BLOB",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"timeout": "7.00:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"source": {
								"type": "JsonSource",
								"storeSettings": {
									"type": "AzureBlobStorageReadSettings",
									"recursive": true
								},
								"formatSettings": {
									"type": "JsonReadSettings"
								}
							},
							"dataset": {
								"referenceName": "test_restapi_blob_json_param",
								"type": "DatasetReference",
								"parameters": {
									"ds_fname": {
										"value": "@pipeline().parameters.pl_fname",
										"type": "Expression"
									}
								}
							},
							"firstRowOnly": false
						}
					}
				],
				"policy": {
					"elapsedTimeMetric": {},
					"cancelAfter": {}
				},
				"parameters": {
					"pl_fname": {
						"type": "string"
					}
				},
				"folder": {
					"name": "zmy02_CDR"
				},
				"annotations": [],
				"lastPublishTime": "2020-10-06T06:35:37Z"
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/test_tbl_to_blob')]",
			"type": "Microsoft.DataFactory/factories/pipelines",
			"apiVersion": "2018-06-01",
			"properties": {
				"activities": [
					{
						"name": "Copy data1",
						"type": "Copy",
						"dependsOn": [],
						"policy": {
							"timeout": "7.00:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"source": {
								"type": "AzureSqlSource",
								"queryTimeout": "02:00:00",
								"partitionOption": "None"
							},
							"sink": {
								"type": "DelimitedTextSink",
								"storeSettings": {
									"type": "AzureBlobFSWriteSettings"
								},
								"formatSettings": {
									"type": "DelimitedTextWriteSettings",
									"quoteAllText": true,
									"fileExtension": ".csv"
								}
							},
							"enableStaging": false,
							"translator": {
								"type": "TabularTranslator",
								"typeConversion": true,
								"typeConversionSettings": {
									"allowDataTruncation": true,
									"treatBooleanAsNumber": false
								}
							}
						},
						"inputs": [
							{
								"referenceName": "CarsTable",
								"type": "DatasetReference",
								"parameters": {}
							}
						],
						"outputs": [
							{
								"referenceName": "DS_DataLakeGen2_Cars",
								"type": "DatasetReference",
								"parameters": {}
							}
						]
					}
				],
				"policy": {
					"elapsedTimeMetric": {},
					"cancelAfter": {}
				},
				"folder": {
					"name": "zmy00_Misc"
				},
				"annotations": [],
				"lastPublishTime": "2020-09-30T10:01:17Z"
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/Onprem_cars_table')]",
			"type": "Microsoft.DataFactory/factories/datasets",
			"apiVersion": "2018-06-01",
			"properties": {
				"linkedServiceName": {
					"referenceName": "Onpremsql",
					"type": "LinkedServiceReference"
				},
				"folder": {
					"name": "zmy00_Misc"
				},
				"annotations": [],
				"type": "SqlServerTable",
				"schema": [
					{
						"name": "ID",
						"type": "int",
						"precision": 10
					},
					{
						"name": "Name",
						"type": "varchar"
					},
					{
						"name": "Model",
						"type": "varchar"
					},
					{
						"name": "Length",
						"type": "int",
						"precision": 10
					}
				],
				"typeProperties": {
					"schema": "dbo",
					"table": "Cars"
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/DF_LoadFactSales2')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"folder": {
					"name": "bidesign"
				},
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "DS_Db_Static",
								"type": "DatasetReference"
							},
							"name": "StagingFact"
						},
						{
							"dataset": {
								"referenceName": "DS_Db_Static",
								"type": "DatasetReference"
							},
							"name": "DimCustomer"
						},
						{
							"dataset": {
								"referenceName": "DS_Db_Static",
								"type": "DatasetReference"
							},
							"name": "DimProduct"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "DS_Db_FactSales2",
								"type": "DatasetReference"
							},
							"name": "LoadFactSales2"
						}
					],
					"transformations": [
						{
							"name": "GetCustomerKey"
						},
						{
							"name": "GetProductKey"
						},
						{
							"name": "DerivedColumn"
						}
					],
					"script": "source(output(\n\t\ttransaction_id as string,\n\t\tproduct_id as string,\n\t\tcustomer_id as string\n\t),\n\tallowSchemaDrift: true,\n\tvalidateSchema: false,\n\tisolationLevel: 'READ_UNCOMMITTED',\n\tquery: 'SELECT * FROM [staging].[Sales]',\n\tformat: 'query') ~> StagingFact\nsource(output(\n\t\tCustomerKey as integer,\n\t\tCustomerId as string\n\t),\n\tallowSchemaDrift: true,\n\tvalidateSchema: false,\n\tisolationLevel: 'READ_UNCOMMITTED',\n\tquery: 'select CustomerKey, CustomerId from [dbo].[DimCustomer]',\n\tformat: 'query') ~> DimCustomer\nsource(output(\n\t\tProductKey as integer,\n\t\tProductId as string\n\t),\n\tallowSchemaDrift: true,\n\tvalidateSchema: false,\n\tisolationLevel: 'READ_UNCOMMITTED',\n\tquery: 'select ProductKey, ProductId from [dbo].[DimProduct]',\n\tformat: 'query') ~> DimProduct\nStagingFact, DimCustomer join(customer_id == CustomerId,\n\tjoinType:'left',\n\tmatchType:'exact',\n\tignoreSpaces: false,\n\tbroadcast: 'auto')~> GetCustomerKey\nGetCustomerKey, DimProduct join(product_id == ProductId,\n\tjoinType:'left',\n\tmatchType:'exact',\n\tignoreSpaces: false,\n\tbroadcast: 'auto')~> GetProductKey\nGetProductKey derive(NewCustomerKey = iifNull(CustomerKey, -1, CustomerKey),\n\t\tNewProductKey = iifNull(ProductKey, -1, ProductKey)) ~> DerivedColumn\nDerivedColumn sink(allowSchemaDrift: true,\n\tvalidateSchema: false,\n\tinput(\n\t\tSalesKey as integer,\n\t\tTransactionId as string,\n\t\tProductKey as integer,\n\t\tCustomerKey as integer,\n\t\tInsertTime as timestamp,\n\t\tInsertUser as string,\n\t\tLastUpdateTime as timestamp,\n\t\tLastUpdateUser as string\n\t),\n\tdeletable:false,\n\tinsertable:true,\n\tupdateable:false,\n\tupsertable:false,\n\tformat: 'table',\n\tskipDuplicateMapInputs: true,\n\tskipDuplicateMapOutputs: true,\n\terrorHandlingOption: 'stopOnFirstError',\n\tmapColumn(\n\t\tTransactionId = transaction_id,\n\t\tProductKey = NewProductKey,\n\t\tCustomerKey = NewCustomerKey\n\t)) ~> LoadFactSales2"
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/MoviesCleanFlow')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"folder": {
					"name": "zmy00_Misc"
				},
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "dfMoviesCSV_input",
								"type": "DatasetReference"
							},
							"name": "Movies"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "dfMoviesCSV_output",
								"type": "DatasetReference"
							},
							"name": "MoviesClean"
						},
						{
							"dataset": {
								"referenceName": "dfMoviesCSV_output",
								"type": "DatasetReference"
							},
							"name": "MoviesByYearSink"
						}
					],
					"transformations": [
						{
							"name": "YearExtraction"
						},
						{
							"name": "MoviesByYear"
						}
					],
					"script": "source(output(\n\t\tmovieId as string,\n\t\ttitle as string,\n\t\tgenres as string\n\t),\n\tallowSchemaDrift: true,\n\tvalidateSchema: false,\n\tignoreNoFilesFound: false) ~> Movies\nMovies derive(Year = toInteger(trim(right(title, 6), '()')),\n\t\ttitle = toString(left(title, length(title)-6)),\n\tpartitionBy('hash', 1)) ~> YearExtraction\nYearExtraction aggregate(groupBy(Year),\n\tMoviesCount = count(),\n\tpartitionBy('hash', 1)) ~> MoviesByYear\nYearExtraction sink(allowSchemaDrift: true,\n\tvalidateSchema: false,\n\tpartitionFileNames:['movies-clean.csv'],\n\tskipDuplicateMapInputs: true,\n\tskipDuplicateMapOutputs: true,\n\tmapColumn(\n\t\tmovieId,\n\t\ttitle,\n\t\tgenres,\n\t\tYear\n\t),\n\tpartitionBy('hash', 1)) ~> MoviesClean\nMoviesByYear sink(allowSchemaDrift: true,\n\tvalidateSchema: false,\n\tpartitionFileNames:['movies-by-year.csv'],\n\tskipDuplicateMapInputs: true,\n\tskipDuplicateMapOutputs: true,\n\tpartitionBy('hash', 1)) ~> MoviesByYearSink"
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/df_LoadDimTeamType1')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"folder": {
					"name": "zmy01_IncLoad_SCD"
				},
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "ds_stgTeam",
								"type": "DatasetReference"
							},
							"name": "StageTable"
						},
						{
							"dataset": {
								"referenceName": "ds_dimTeam",
								"type": "DatasetReference"
							},
							"name": "DimTable"
						},
						{
							"dataset": {
								"referenceName": "ds_dimTeam",
								"type": "DatasetReference"
							},
							"name": "MaxTeamKey"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "ds_dimTeam",
								"type": "DatasetReference"
							},
							"name": "InsertSink"
						},
						{
							"dataset": {
								"referenceName": "ds_dimTeam",
								"type": "DatasetReference"
							},
							"name": "UpdateSink"
						}
					],
					"transformations": [
						{
							"name": "DimTableRenameCols"
						},
						{
							"name": "StageHash"
						},
						{
							"name": "Exists"
						},
						{
							"name": "Lookup"
						},
						{
							"name": "ConditionalSplit"
						},
						{
							"name": "JoinMax"
						},
						{
							"name": "SurrogateKey"
						},
						{
							"name": "InsertDerivedColumn"
						},
						{
							"name": "AlterRowInsert"
						},
						{
							"name": "UpdateDerivedColumn"
						},
						{
							"name": "AlterRowUpdate"
						}
					],
					"script": "source(output(\n\t\tTeamCode as string,\n\t\tLocation as string,\n\t\tNickName as string,\n\t\tConferenceCode as string,\n\t\tDivisionName as string,\n\t\tLastUpdateDate as timestamp\n\t),\n\tallowSchemaDrift: true,\n\tvalidateSchema: false,\n\tisolationLevel: 'READ_UNCOMMITTED',\n\tformat: 'table') ~> StageTable\nsource(output(\n\t\tTeamKey as integer,\n\t\tTeamCode as string,\n\t\tRecordHash as string\n\t),\n\tallowSchemaDrift: true,\n\tvalidateSchema: false,\n\tisolationLevel: 'READ_UNCOMMITTED',\n\tquery: 'SELECT TeamKey, TeamCode, RecordHash\\nFROM zmy01_dim_team',\n\tformat: 'query') ~> DimTable\nsource(output(\n\t\tMaxTeamKey as integer\n\t),\n\tallowSchemaDrift: true,\n\tvalidateSchema: false,\n\tisolationLevel: 'READ_UNCOMMITTED',\n\tquery: 'SELECT MaxTeamKey = ISNULL(MAX(TeamKey), 0)\\nFROM zmy01_dim_team',\n\tformat: 'query') ~> MaxTeamKey\nDimTable select(mapColumn(\n\t\tDimTeamKey = TeamKey,\n\t\tDimTeamCode = TeamCode,\n\t\tDimRecordHash = RecordHash\n\t),\n\tskipDuplicateMapInputs: true,\n\tskipDuplicateMapOutputs: true) ~> DimTableRenameCols\nStageTable derive(StageRecordHash = sha2(256, TeamCode, Location, NickName, ConferenceCode, DivisionName)) ~> StageHash\nStageHash, DimTableRenameCols exists(StageRecordHash == DimRecordHash,\n\tnegate:true,\n\tbroadcast: 'auto')~> Exists\nExists, DimTableRenameCols lookup(TeamCode == DimTeamCode,\n\tmultiple: false,\n\tpickup: 'any',\n\tbroadcast: 'auto')~> Lookup\nLookup split(isNull(DimTeamKey),\n\tdisjoint: false) ~> ConditionalSplit@(NewItem, UpdatedItem)\nConditionalSplit@NewItem, MaxTeamKey join(1==1,\n\tjoinType:'cross',\n\tmatchType:'exact',\n\tignoreSpaces: false,\n\tbroadcast: 'auto')~> JoinMax\nJoinMax keyGenerate(output(NewTeamKey as long),\n\tstartAt: 1L,\n\tstepValue: 1L) ~> SurrogateKey\nSurrogateKey derive(NewTeamKey = NewTeamKey + MaxTeamKey,\n\t\tDWIsCurrent = 1,\n\t\tDWEffectiveEndDate = toDate('2100-01-01'),\n\t\tRecordCreateDate = currentUTC(),\n\t\tRecordUpdateDate = currentUTC()) ~> InsertDerivedColumn\nInsertDerivedColumn alterRow(insertIf(1==1)) ~> AlterRowInsert\nConditionalSplit@UpdatedItem derive(RecordUpdateDate = currentUTC()) ~> UpdateDerivedColumn\nUpdateDerivedColumn alterRow(updateIf(1==1)) ~> AlterRowUpdate\nAlterRowInsert sink(allowSchemaDrift: true,\n\tvalidateSchema: false,\n\tdeletable:false,\n\tinsertable:true,\n\tupdateable:false,\n\tupsertable:false,\n\tformat: 'table',\n\tskipDuplicateMapInputs: true,\n\tskipDuplicateMapOutputs: true,\n\terrorHandlingOption: 'stopOnFirstError',\n\tmapColumn(\n\t\tTeamCode,\n\t\tLocation,\n\t\tNickName,\n\t\tConferenceCode,\n\t\tDivisionName,\n\t\tRecordHash = StageRecordHash,\n\t\tTeamKey = NewTeamKey,\n\t\tDWIsCurrent,\n\t\tDWEffectiveStartDate = LastUpdateDate,\n\t\tDWEffectiveEndDate,\n\t\tRecordCreateDate,\n\t\tRecordUpdateDate\n\t)) ~> InsertSink\nAlterRowUpdate sink(allowSchemaDrift: true,\n\tvalidateSchema: false,\n\tdeletable:false,\n\tinsertable:false,\n\tupdateable:true,\n\tupsertable:false,\n\tkeys:['TeamKey'],\n\tformat: 'table',\n\tskipDuplicateMapInputs: true,\n\tskipDuplicateMapOutputs: true,\n\terrorHandlingOption: 'stopOnFirstError',\n\tmapColumn(\n\t\tTeamCode,\n\t\tLocation,\n\t\tNickName,\n\t\tConferenceCode,\n\t\tDivisionName,\n\t\tRecordHash = StageRecordHash,\n\t\tTeamKey = DimTeamKey,\n\t\tRecordUpdateDate,\n\t\tDWEffectiveStartDate = LastUpdateDate\n\t)) ~> UpdateSink"
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/df_LoadDimTeamType1_V2')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"description": "SCD Dim Type 1 - V2: source StageTable first removes duplicate business keys and just takes the last record",
				"folder": {
					"name": "zmy01_IncLoad_SCD"
				},
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "ds_stgTeam",
								"type": "DatasetReference"
							},
							"name": "StageTable"
						},
						{
							"dataset": {
								"referenceName": "ds_dimTeam",
								"type": "DatasetReference"
							},
							"name": "DimTable"
						},
						{
							"dataset": {
								"referenceName": "ds_dimTeam",
								"type": "DatasetReference"
							},
							"name": "MaxTeamKey"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "ds_dimTeam",
								"type": "DatasetReference"
							},
							"name": "InsertSink"
						},
						{
							"dataset": {
								"referenceName": "ds_dimTeam",
								"type": "DatasetReference"
							},
							"name": "UpdateSink"
						}
					],
					"transformations": [
						{
							"name": "DimTableRenameCols"
						},
						{
							"name": "StageHash"
						},
						{
							"name": "Exists"
						},
						{
							"name": "Lookup"
						},
						{
							"name": "ConditionalSplit"
						},
						{
							"name": "JoinMax"
						},
						{
							"name": "SurrogateKey"
						},
						{
							"name": "InsertDerivedColumn"
						},
						{
							"name": "AlterRowInsert"
						},
						{
							"name": "UpdateDerivedColumn"
						},
						{
							"name": "AlterRowUpdate"
						}
					],
					"script": "source(output(\n\t\tTeamCode as string,\n\t\tLocation as string,\n\t\tNickName as string,\n\t\tConferenceCode as string,\n\t\tDivisionName as string,\n\t\tLastUpdateDate as timestamp\n\t),\n\tallowSchemaDrift: true,\n\tvalidateSchema: false,\n\tisolationLevel: 'READ_UNCOMMITTED',\n\tquery: 'SELECT dup.* \\nFROM\\n(\\n   SELECT ROW_NUMBER() OVER (PARTITION BY TeamCode ORDER BY LastUpdateDate desc) AS val\\n , stg.*\\n FROM zmy01_stg_team stg\\n) dup\\nWHERE dup.val = 1',\n\tformat: 'query') ~> StageTable\nsource(output(\n\t\tTeamKey as integer,\n\t\tTeamCode as string,\n\t\tRecordHash as string\n\t),\n\tallowSchemaDrift: true,\n\tvalidateSchema: false,\n\tisolationLevel: 'READ_UNCOMMITTED',\n\tquery: 'SELECT TeamKey, TeamCode, RecordHash\\nFROM zmy01_dim_team',\n\tformat: 'query') ~> DimTable\nsource(output(\n\t\tMaxTeamKey as integer\n\t),\n\tallowSchemaDrift: true,\n\tvalidateSchema: false,\n\tisolationLevel: 'READ_UNCOMMITTED',\n\tquery: 'SELECT MaxTeamKey = ISNULL(MAX(TeamKey), 0)\\nFROM zmy01_dim_team',\n\tformat: 'query') ~> MaxTeamKey\nDimTable select(mapColumn(\n\t\tDimTeamKey = TeamKey,\n\t\tDimTeamCode = TeamCode,\n\t\tDimRecordHash = RecordHash\n\t),\n\tskipDuplicateMapInputs: true,\n\tskipDuplicateMapOutputs: true) ~> DimTableRenameCols\nStageTable derive(StageRecordHash = sha2(256, TeamCode, Location, NickName, ConferenceCode, DivisionName)) ~> StageHash\nStageHash, DimTableRenameCols exists(StageRecordHash == DimRecordHash,\n\tnegate:true,\n\tbroadcast: 'auto')~> Exists\nExists, DimTableRenameCols lookup(TeamCode == DimTeamCode,\n\tmultiple: false,\n\tpickup: 'any',\n\tbroadcast: 'auto')~> Lookup\nLookup split(isNull(DimTeamKey),\n\tdisjoint: false) ~> ConditionalSplit@(NewItem, UpdatedItem)\nConditionalSplit@NewItem, MaxTeamKey join(1==1,\n\tjoinType:'cross',\n\tmatchType:'exact',\n\tignoreSpaces: false,\n\tbroadcast: 'auto')~> JoinMax\nJoinMax keyGenerate(output(NewTeamKey as long),\n\tstartAt: 1L,\n\tstepValue: 1L) ~> SurrogateKey\nSurrogateKey derive(NewTeamKey = NewTeamKey + MaxTeamKey,\n\t\tDWIsCurrent = 1,\n\t\tDWEffectiveEndDate = toDate('2100-01-01'),\n\t\tRecordCreateDate = currentUTC(),\n\t\tRecordUpdateDate = currentUTC()) ~> InsertDerivedColumn\nInsertDerivedColumn alterRow(insertIf(1==1)) ~> AlterRowInsert\nConditionalSplit@UpdatedItem derive(RecordUpdateDate = currentUTC()) ~> UpdateDerivedColumn\nUpdateDerivedColumn alterRow(updateIf(1==1)) ~> AlterRowUpdate\nAlterRowInsert sink(allowSchemaDrift: true,\n\tvalidateSchema: false,\n\tdeletable:false,\n\tinsertable:true,\n\tupdateable:false,\n\tupsertable:false,\n\tformat: 'table',\n\tskipDuplicateMapInputs: true,\n\tskipDuplicateMapOutputs: true,\n\terrorHandlingOption: 'stopOnFirstError',\n\tmapColumn(\n\t\tTeamCode,\n\t\tLocation,\n\t\tNickName,\n\t\tConferenceCode,\n\t\tDivisionName,\n\t\tRecordHash = StageRecordHash,\n\t\tTeamKey = NewTeamKey,\n\t\tDWIsCurrent,\n\t\tDWEffectiveStartDate = LastUpdateDate,\n\t\tDWEffectiveEndDate,\n\t\tRecordCreateDate,\n\t\tRecordUpdateDate\n\t)) ~> InsertSink\nAlterRowUpdate sink(allowSchemaDrift: true,\n\tvalidateSchema: false,\n\tdeletable:false,\n\tinsertable:false,\n\tupdateable:true,\n\tupsertable:false,\n\tkeys:['TeamKey'],\n\tformat: 'table',\n\tskipDuplicateMapInputs: true,\n\tskipDuplicateMapOutputs: true,\n\terrorHandlingOption: 'stopOnFirstError',\n\tmapColumn(\n\t\tTeamCode,\n\t\tLocation,\n\t\tNickName,\n\t\tConferenceCode,\n\t\tDivisionName,\n\t\tRecordHash = StageRecordHash,\n\t\tTeamKey = DimTeamKey,\n\t\tRecordUpdateDate,\n\t\tDWEffectiveStartDate = LastUpdateDate\n\t)) ~> UpdateSink"
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/df_LoadDimTeamType2')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"folder": {
					"name": "zmy01_IncLoad_SCD"
				},
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "ds_stgTeam",
								"type": "DatasetReference"
							},
							"name": "StageTable"
						},
						{
							"dataset": {
								"referenceName": "ds_dimTeam",
								"type": "DatasetReference"
							},
							"name": "DimTable"
						},
						{
							"dataset": {
								"referenceName": "ds_dimTeam",
								"type": "DatasetReference"
							},
							"name": "MaxTeamKey"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "ds_dimTeam",
								"type": "DatasetReference"
							},
							"name": "InsertSink"
						},
						{
							"dataset": {
								"referenceName": "ds_dimTeam",
								"type": "DatasetReference"
							},
							"name": "UpdateSink"
						}
					],
					"transformations": [
						{
							"name": "StageHash"
						},
						{
							"name": "Exists"
						},
						{
							"name": "Lookup"
						},
						{
							"name": "DimTableRenameCols"
						},
						{
							"name": "JoinMax"
						},
						{
							"name": "SurrogateKey"
						},
						{
							"name": "InsertDerivedColumn"
						},
						{
							"name": "AlterRowInsert"
						},
						{
							"name": "ConditionalSplit"
						},
						{
							"name": "UpdateDerivedColumn"
						},
						{
							"name": "AlterRowUpdate"
						}
					],
					"script": "source(output(\n\t\tTeamCode as string,\n\t\tLocation as string,\n\t\tNickName as string,\n\t\tConferenceCode as string,\n\t\tDivisionName as string,\n\t\tLastUpdateDate as timestamp\n\t),\n\tallowSchemaDrift: true,\n\tvalidateSchema: false,\n\tisolationLevel: 'READ_UNCOMMITTED',\n\tformat: 'table') ~> StageTable\nsource(output(\n\t\tTeamKey as integer,\n\t\tTeamCode as string,\n\t\tRecordHash as string\n\t),\n\tallowSchemaDrift: true,\n\tvalidateSchema: false,\n\tisolationLevel: 'READ_UNCOMMITTED',\n\tquery: 'SELECT TeamKey, TeamCode, RecordHash\\nFROM zmy01_dim_team\\nWHERE DWIsCurrent = 1',\n\tformat: 'query') ~> DimTable\nsource(output(\n\t\tMaxTeamKey as integer\n\t),\n\tallowSchemaDrift: true,\n\tvalidateSchema: false,\n\tisolationLevel: 'READ_UNCOMMITTED',\n\tquery: 'SELECT MaxTeamKey = ISNULL(MAX(TeamKey), 0)\\nFROM zmy01_dim_team',\n\tformat: 'query') ~> MaxTeamKey\nStageTable derive(StageRecordHash = sha2(256, TeamCode, Location, NickName, ConferenceCode, DivisionName)) ~> StageHash\nStageHash, DimTableRenameCols exists(StageRecordHash == DimRecordHash,\n\tnegate:true,\n\tbroadcast: 'auto')~> Exists\nExists, DimTableRenameCols lookup(TeamCode == DimTeamCode,\n\tmultiple: false,\n\tpickup: 'any',\n\tbroadcast: 'auto')~> Lookup\nDimTable select(mapColumn(\n\t\tDimTeamKey = TeamKey,\n\t\tDimTeamCode = TeamCode,\n\t\tDimRecordHash = RecordHash\n\t),\n\tskipDuplicateMapInputs: true,\n\tskipDuplicateMapOutputs: true) ~> DimTableRenameCols\nLookup, MaxTeamKey join(1==1,\n\tjoinType:'cross',\n\tmatchType:'exact',\n\tignoreSpaces: false,\n\tbroadcast: 'auto')~> JoinMax\nJoinMax keyGenerate(output(NewTeamKey as long),\n\tstartAt: 1L,\n\tstepValue: 1L) ~> SurrogateKey\nSurrogateKey derive(NewTeamKey = NewTeamKey + MaxTeamKey,\n\t\tDWIsCurrent = 1,\n\t\tDWEffectiveEndDate = toDate('2100-01-01'),\n\t\tRecordCreateDate = currentUTC(),\n\t\tRecordUpdateDate = currentUTC()) ~> InsertDerivedColumn\nInsertDerivedColumn alterRow(insertIf(1==1)) ~> AlterRowInsert\nLookup split(!isNull(DimTeamKey),\n\tdisjoint: false) ~> ConditionalSplit@(RecordsToBeUpdated, NewRecordsDoNotProcess)\nConditionalSplit@RecordsToBeUpdated derive(DWIsCurrent = 0,\n\t\tDWEffectiveEndDate = LastUpdateDate,\n\t\tRecordUpdateDate = currentUTC()) ~> UpdateDerivedColumn\nUpdateDerivedColumn alterRow(updateIf(1==1)) ~> AlterRowUpdate\nAlterRowInsert sink(allowSchemaDrift: true,\n\tvalidateSchema: false,\n\tdeletable:false,\n\tinsertable:true,\n\tupdateable:false,\n\tupsertable:false,\n\tformat: 'table',\n\tskipDuplicateMapInputs: true,\n\tskipDuplicateMapOutputs: true,\n\terrorHandlingOption: 'stopOnFirstError',\n\tmapColumn(\n\t\tTeamCode,\n\t\tLocation,\n\t\tNickName,\n\t\tConferenceCode,\n\t\tDivisionName,\n\t\tDWEffectiveStartDate = LastUpdateDate,\n\t\tRecordHash = StageRecordHash,\n\t\tTeamKey = NewTeamKey,\n\t\tDWIsCurrent,\n\t\tDWEffectiveEndDate,\n\t\tRecordCreateDate,\n\t\tRecordUpdateDate\n\t)) ~> InsertSink\nAlterRowUpdate sink(allowSchemaDrift: true,\n\tvalidateSchema: false,\n\tdeletable:false,\n\tinsertable:false,\n\tupdateable:true,\n\tupsertable:false,\n\tkeys:['TeamKey'],\n\tformat: 'table',\n\tskipDuplicateMapInputs: true,\n\tskipDuplicateMapOutputs: true,\n\terrorHandlingOption: 'stopOnFirstError',\n\tmapColumn(\n\t\tTeamKey = DimTeamKey,\n\t\tDWIsCurrent,\n\t\tDWEffectiveEndDate,\n\t\tRecordUpdateDate\n\t)) ~> UpdateSink"
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/df_LoadDimTeamType2_V2')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"description": "SCD Dim Type 2 - V2: source StageTable first removes duplicate business keys and just takes the last record",
				"folder": {
					"name": "zmy01_IncLoad_SCD"
				},
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "ds_stgTeam",
								"type": "DatasetReference"
							},
							"name": "StageTable"
						},
						{
							"dataset": {
								"referenceName": "ds_dimTeam",
								"type": "DatasetReference"
							},
							"name": "DimTable"
						},
						{
							"dataset": {
								"referenceName": "ds_dimTeam",
								"type": "DatasetReference"
							},
							"name": "MaxTeamKey"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "ds_dimTeam",
								"type": "DatasetReference"
							},
							"name": "InsertSink"
						},
						{
							"dataset": {
								"referenceName": "ds_dimTeam",
								"type": "DatasetReference"
							},
							"name": "UpdateSink"
						}
					],
					"transformations": [
						{
							"name": "StageHash"
						},
						{
							"name": "Exists"
						},
						{
							"name": "Lookup"
						},
						{
							"name": "DimTableRenameCols"
						},
						{
							"name": "JoinMax"
						},
						{
							"name": "SurrogateKey"
						},
						{
							"name": "InsertDerivedColumn"
						},
						{
							"name": "AlterRowInsert"
						},
						{
							"name": "ConditionalSplit"
						},
						{
							"name": "UpdateDerivedColumn"
						},
						{
							"name": "AlterRowUpdate"
						}
					],
					"script": "source(output(\n\t\tTeamCode as string,\n\t\tLocation as string,\n\t\tNickName as string,\n\t\tConferenceCode as string,\n\t\tDivisionName as string,\n\t\tLastUpdateDate as timestamp\n\t),\n\tallowSchemaDrift: true,\n\tvalidateSchema: false,\n\tisolationLevel: 'READ_UNCOMMITTED',\n\tquery: 'SELECT dup.* \\nFROM\\n(\\n   SELECT ROW_NUMBER() OVER (PARTITION BY TeamCode ORDER BY LastUpdateDate desc) AS val\\n , stg.*\\n FROM zmy01_stg_team stg\\n) dup\\nWHERE dup.val = 1\\n',\n\tformat: 'query') ~> StageTable\nsource(output(\n\t\tTeamKey as integer,\n\t\tTeamCode as string,\n\t\tRecordHash as string\n\t),\n\tallowSchemaDrift: true,\n\tvalidateSchema: false,\n\tisolationLevel: 'READ_UNCOMMITTED',\n\tquery: 'SELECT TeamKey, TeamCode, RecordHash\\nFROM zmy01_dim_team\\nWHERE DWIsCurrent = 1',\n\tformat: 'query') ~> DimTable\nsource(output(\n\t\tMaxTeamKey as integer\n\t),\n\tallowSchemaDrift: true,\n\tvalidateSchema: false,\n\tisolationLevel: 'READ_UNCOMMITTED',\n\tquery: 'SELECT MaxTeamKey = ISNULL(MAX(TeamKey), 0)\\nFROM zmy01_dim_team',\n\tformat: 'query') ~> MaxTeamKey\nStageTable derive(StageRecordHash = sha2(256, TeamCode, Location, NickName, ConferenceCode, DivisionName)) ~> StageHash\nStageHash, DimTableRenameCols exists(StageRecordHash == DimRecordHash,\n\tnegate:true,\n\tbroadcast: 'auto')~> Exists\nExists, DimTableRenameCols lookup(TeamCode == DimTeamCode,\n\tmultiple: false,\n\tpickup: 'any',\n\tbroadcast: 'auto')~> Lookup\nDimTable select(mapColumn(\n\t\tDimTeamKey = TeamKey,\n\t\tDimTeamCode = TeamCode,\n\t\tDimRecordHash = RecordHash\n\t),\n\tskipDuplicateMapInputs: true,\n\tskipDuplicateMapOutputs: true) ~> DimTableRenameCols\nLookup, MaxTeamKey join(1==1,\n\tjoinType:'cross',\n\tmatchType:'exact',\n\tignoreSpaces: false,\n\tbroadcast: 'auto')~> JoinMax\nJoinMax keyGenerate(output(NewTeamKey as long),\n\tstartAt: 1L,\n\tstepValue: 1L) ~> SurrogateKey\nSurrogateKey derive(NewTeamKey = NewTeamKey + MaxTeamKey,\n\t\tDWIsCurrent = 1,\n\t\tDWEffectiveEndDate = toDate('2100-01-01'),\n\t\tRecordCreateDate = currentUTC(),\n\t\tRecordUpdateDate = currentUTC()) ~> InsertDerivedColumn\nInsertDerivedColumn alterRow(insertIf(1==1)) ~> AlterRowInsert\nLookup split(!isNull(DimTeamKey),\n\tdisjoint: false) ~> ConditionalSplit@(RecordsToBeUpdated, NewRecordsDoNotProcess)\nConditionalSplit@RecordsToBeUpdated derive(DWIsCurrent = 0,\n\t\tDWEffectiveEndDate = LastUpdateDate,\n\t\tRecordUpdateDate = currentUTC()) ~> UpdateDerivedColumn\nUpdateDerivedColumn alterRow(updateIf(1==1)) ~> AlterRowUpdate\nAlterRowInsert sink(allowSchemaDrift: true,\n\tvalidateSchema: false,\n\tdeletable:false,\n\tinsertable:true,\n\tupdateable:false,\n\tupsertable:false,\n\tformat: 'table',\n\tskipDuplicateMapInputs: true,\n\tskipDuplicateMapOutputs: true,\n\terrorHandlingOption: 'stopOnFirstError',\n\tmapColumn(\n\t\tTeamCode,\n\t\tLocation,\n\t\tNickName,\n\t\tConferenceCode,\n\t\tDivisionName,\n\t\tDWEffectiveStartDate = LastUpdateDate,\n\t\tRecordHash = StageRecordHash,\n\t\tTeamKey = NewTeamKey,\n\t\tDWIsCurrent,\n\t\tDWEffectiveEndDate,\n\t\tRecordCreateDate,\n\t\tRecordUpdateDate\n\t)) ~> InsertSink\nAlterRowUpdate sink(allowSchemaDrift: true,\n\tvalidateSchema: false,\n\tdeletable:false,\n\tinsertable:false,\n\tupdateable:true,\n\tupsertable:false,\n\tkeys:['TeamKey'],\n\tformat: 'table',\n\tskipDuplicateMapInputs: true,\n\tskipDuplicateMapOutputs: true,\n\terrorHandlingOption: 'stopOnFirstError',\n\tmapColumn(\n\t\tTeamKey = DimTeamKey,\n\t\tDWIsCurrent,\n\t\tDWEffectiveEndDate,\n\t\tRecordUpdateDate\n\t)) ~> UpdateSink"
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/df_LoadDimTeamType2_V2_1')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"description": "From source DimTable removed WHERE DWIsCurrent = 1",
				"folder": {
					"name": "zmy01_IncLoad_SCD"
				},
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "ds_stgTeam",
								"type": "DatasetReference"
							},
							"name": "StageTable"
						},
						{
							"dataset": {
								"referenceName": "ds_dimTeam",
								"type": "DatasetReference"
							},
							"name": "DimTable"
						},
						{
							"dataset": {
								"referenceName": "ds_dimTeam",
								"type": "DatasetReference"
							},
							"name": "MaxTeamKey"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "ds_dimTeam",
								"type": "DatasetReference"
							},
							"name": "InsertSink"
						},
						{
							"dataset": {
								"referenceName": "ds_dimTeam",
								"type": "DatasetReference"
							},
							"name": "UpdateSink"
						}
					],
					"transformations": [
						{
							"name": "StageHash"
						},
						{
							"name": "Exists"
						},
						{
							"name": "Lookup"
						},
						{
							"name": "DimTableRenameCols"
						},
						{
							"name": "JoinMax"
						},
						{
							"name": "SurrogateKey"
						},
						{
							"name": "InsertDerivedColumn"
						},
						{
							"name": "AlterRowInsert"
						},
						{
							"name": "ConditionalSplit"
						},
						{
							"name": "UpdateDerivedColumn"
						},
						{
							"name": "AlterRowUpdate"
						}
					],
					"script": "source(output(\n\t\tTeamCode as string,\n\t\tLocation as string,\n\t\tNickName as string,\n\t\tConferenceCode as string,\n\t\tDivisionName as string,\n\t\tLastUpdateDate as timestamp\n\t),\n\tallowSchemaDrift: true,\n\tvalidateSchema: false,\n\tisolationLevel: 'READ_UNCOMMITTED',\n\tformat: 'table') ~> StageTable\nsource(output(\n\t\tTeamKey as integer,\n\t\tTeamCode as string,\n\t\tRecordHash as string\n\t),\n\tallowSchemaDrift: true,\n\tvalidateSchema: false,\n\tisolationLevel: 'READ_UNCOMMITTED',\n\tquery: 'SELECT TeamKey, TeamCode, RecordHash\\nFROM zmy01_dim_team',\n\tformat: 'query') ~> DimTable\nsource(output(\n\t\tMaxTeamKey as integer\n\t),\n\tallowSchemaDrift: true,\n\tvalidateSchema: false,\n\tisolationLevel: 'READ_UNCOMMITTED',\n\tquery: 'SELECT MaxTeamKey = ISNULL(MAX(TeamKey), 0)\\nFROM zmy01_dim_team',\n\tformat: 'query') ~> MaxTeamKey\nStageTable derive(StageRecordHash = sha2(256, TeamCode, Location, NickName, ConferenceCode, DivisionName)) ~> StageHash\nStageHash, DimTableRenameCols exists(StageRecordHash == DimRecordHash,\n\tnegate:true,\n\tbroadcast: 'auto')~> Exists\nExists, DimTableRenameCols lookup(TeamCode == DimTeamCode,\n\tmultiple: false,\n\tpickup: 'any',\n\tbroadcast: 'auto')~> Lookup\nDimTable select(mapColumn(\n\t\tDimTeamKey = TeamKey,\n\t\tDimTeamCode = TeamCode,\n\t\tDimRecordHash = RecordHash\n\t),\n\tskipDuplicateMapInputs: true,\n\tskipDuplicateMapOutputs: true) ~> DimTableRenameCols\nLookup, MaxTeamKey join(1==1,\n\tjoinType:'cross',\n\tmatchType:'exact',\n\tignoreSpaces: false,\n\tbroadcast: 'auto')~> JoinMax\nJoinMax keyGenerate(output(NewTeamKey as long),\n\tstartAt: 1L,\n\tstepValue: 1L) ~> SurrogateKey\nSurrogateKey derive(NewTeamKey = NewTeamKey + MaxTeamKey,\n\t\tDWIsCurrent = 1,\n\t\tDWEffectiveEndDate = toDate('2100-01-01'),\n\t\tRecordCreateDate = currentUTC(),\n\t\tRecordUpdateDate = currentUTC()) ~> InsertDerivedColumn\nInsertDerivedColumn alterRow(insertIf(1==1)) ~> AlterRowInsert\nLookup split(!isNull(DimTeamKey),\n\tdisjoint: false) ~> ConditionalSplit@(RecordsToBeUpdated, NewRecordsDoNotProcess)\nConditionalSplit@RecordsToBeUpdated derive(DWIsCurrent = 0,\n\t\tDWEffectiveEndDate = LastUpdateDate,\n\t\tRecordUpdateDate = currentUTC()) ~> UpdateDerivedColumn\nUpdateDerivedColumn alterRow(updateIf(1==1)) ~> AlterRowUpdate\nAlterRowInsert sink(allowSchemaDrift: true,\n\tvalidateSchema: false,\n\tdeletable:false,\n\tinsertable:true,\n\tupdateable:false,\n\tupsertable:false,\n\tformat: 'table',\n\tskipDuplicateMapInputs: true,\n\tskipDuplicateMapOutputs: true,\n\terrorHandlingOption: 'stopOnFirstError',\n\tmapColumn(\n\t\tTeamCode,\n\t\tLocation,\n\t\tNickName,\n\t\tConferenceCode,\n\t\tDivisionName,\n\t\tDWEffectiveStartDate = LastUpdateDate,\n\t\tRecordHash = StageRecordHash,\n\t\tTeamKey = NewTeamKey,\n\t\tDWIsCurrent,\n\t\tDWEffectiveEndDate,\n\t\tRecordCreateDate,\n\t\tRecordUpdateDate\n\t)) ~> InsertSink\nAlterRowUpdate sink(allowSchemaDrift: true,\n\tvalidateSchema: false,\n\tdeletable:false,\n\tinsertable:false,\n\tupdateable:true,\n\tupsertable:false,\n\tkeys:['TeamKey'],\n\tformat: 'table',\n\tskipDuplicateMapInputs: true,\n\tskipDuplicateMapOutputs: true,\n\terrorHandlingOption: 'stopOnFirstError',\n\tmapColumn(\n\t\tTeamKey = DimTeamKey,\n\t\tDWIsCurrent,\n\t\tDWEffectiveEndDate,\n\t\tRecordUpdateDate\n\t)) ~> UpdateSink"
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/df_LoadFactScore')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"folder": {
					"name": "zmy01_IncLoad_SCD"
				},
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "ds_stgScore",
								"type": "DatasetReference"
							},
							"name": "StagingScore"
						},
						{
							"dataset": {
								"referenceName": "ds_dimTeam",
								"type": "DatasetReference"
							},
							"name": "DimTeam"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "ds_factScore",
								"type": "DatasetReference"
							},
							"name": "FactScore"
						}
					],
					"transformations": [
						{
							"name": "GetTeamKey"
						}
					],
					"script": "source(output(\n\t\tTeamCode as string,\n\t\tScore as integer,\n\t\tLastUpdateDate as timestamp\n\t),\n\tallowSchemaDrift: false,\n\tvalidateSchema: false,\n\tisolationLevel: 'READ_UNCOMMITTED',\n\tformat: 'table') ~> StagingScore\nsource(output(\n\t\tTeamKey as integer,\n\t\tTeamCode as string,\n\t\tDWEffectiveStartDate as timestamp,\n\t\tDWEffectiveEndDate as timestamp\n\t),\n\tallowSchemaDrift: false,\n\tvalidateSchema: false,\n\tisolationLevel: 'READ_UNCOMMITTED',\n\tquery: 'SELECT TeamKey, TeamCode, DWEffectiveStartDate, DWEffectiveEndDate FROM zmy01_dim_team',\n\tformat: 'query') ~> DimTeam\nStagingScore, DimTeam join(StagingScore@TeamCode == DimTeam@TeamCode\n\t&& LastUpdateDate >= DWEffectiveStartDate\n\t&& LastUpdateDate < DWEffectiveEndDate,\n\tjoinType:'left',\n\tmatchType:'exact',\n\tignoreSpaces: false,\n\tbroadcast: 'both')~> GetTeamKey\nGetTeamKey sink(allowSchemaDrift: false,\n\tvalidateSchema: false,\n\tinput(\n\t\tTeamKey as integer,\n\t\tTeamCode as string,\n\t\tScore as integer,\n\t\tLastUpdateDate as timestamp\n\t),\n\tdeletable:false,\n\tinsertable:true,\n\tupdateable:false,\n\tupsertable:false,\n\tformat: 'table',\n\tskipDuplicateMapInputs: true,\n\tskipDuplicateMapOutputs: true,\n\terrorHandlingOption: 'stopOnFirstError',\n\tmapColumn(\n\t\tTeamKey,\n\t\tTeamCode = StagingScore@TeamCode,\n\t\tScore,\n\t\tLastUpdateDate\n\t)) ~> FactScore"
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/dfw_CarsTestAAA')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"type": "WranglingDataFlow",
				"folder": {
					"name": "zmy00_Misc"
				},
				"typeProperties": {
					"sources": [
						{
							"name": "ds_inputCars1",
							"script": "source(allowSchemaDrift: true,\n\tvalidateSchema: false,\n\tignoreNoFilesFound: false) ~>  ds_inputCars1",
							"dataset": {
								"referenceName": "ds_inputCars1",
								"type": "DatasetReference"
							}
						},
						{
							"name": "ds_inputCars2",
							"script": "source(allowSchemaDrift: true,\n\tvalidateSchema: false,\n\tignoreNoFilesFound: false) ~>  ds_inputCars2",
							"dataset": {
								"referenceName": "ds_inputCars2",
								"type": "DatasetReference"
							}
						}
					],
					"script": "section Section1;\r\nshared ds_inputCars1 = let\r\n  AdfDoc = Web.Contents(\"https://bajlecblob.blob.core.windows.net/dfwinput/cars1.csv?sv=2018-03-28&sig=gfcAewXfINxxN69F76TZ2w4c0Xq6J71hMtKghe2KfYI%3D&spr=https&se=2020-09-25T12%3A57%3A57Z&srt=sco&ss=bf&sp=rwl\"),\r\n  Csv = Csv.Document(AdfDoc, [Delimiter = \",\", Encoding = TextEncoding.Utf8, QuoteStyle = QuoteStyle.Csv]),\r\n  PromotedHeaders = Table.PromoteHeaders(Csv, [PromoteAllScalars = true])\r\nin\r\n  PromotedHeaders;\r\nshared ds_inputCars2 = let\r\n  AdfDoc = Web.Contents(\"https://bajlecblob.blob.core.windows.net/dfwinput/cars2.csv?sv=2018-03-28&sig=gfcAewXfINxxN69F76TZ2w4c0Xq6J71hMtKghe2KfYI%3D&spr=https&se=2020-09-25T12%3A57%3A57Z&srt=sco&ss=bf&sp=rwl\"),\r\n  Csv = Csv.Document(AdfDoc, [Delimiter = \",\", Encoding = TextEncoding.Utf8, QuoteStyle = QuoteStyle.Csv]),\r\n  PromotedHeaders = Table.PromoteHeaders(Csv, [PromoteAllScalars = true])\r\nin\r\n  PromotedHeaders;\r\nshared UserQuery = let\r\n  Source = ds_inputCars1,\r\n  #\"Added custom\" = Table.AddColumn(Source, \"MakeModel\", each [Make] & \"-\" & [Model]),\r\n  #\"Changed column type\" = Table.TransformColumnTypes(#\"Added custom\", {{\"MakeModel\", type text}, {\"Length\", Int64.Type}}),\r\n  #\"Merged queries\" = Table.NestedJoin(#\"Changed column type\", {\"Make\"}, ds_inputCars2, {\"Make\"}, \"ds_inputCars2\", JoinKind.LeftOuter),\r\n  #\"Expanded ds_inputCars2\" = Table.ExpandTableColumn(#\"Merged queries\", \"ds_inputCars2\", {\"Origin\"}, {\"Origin\"})\r\nin\r\n  #\"Expanded ds_inputCars2\";\r\n"
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/pl_copy_circuits')]",
			"type": "Microsoft.DataFactory/factories/pipelines",
			"apiVersion": "2018-06-01",
			"properties": {
				"activities": [
					{
						"name": "Copy circuits",
						"type": "Copy",
						"dependsOn": [],
						"policy": {
							"timeout": "7.00:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"source": {
								"type": "DelimitedTextSource",
								"storeSettings": {
									"type": "AzureBlobStorageReadSettings",
									"recursive": true,
									"enablePartitionDiscovery": false
								},
								"formatSettings": {
									"type": "DelimitedTextReadSettings"
								}
							},
							"sink": {
								"type": "DelimitedTextSink",
								"storeSettings": {
									"type": "AzureBlobStorageWriteSettings"
								},
								"formatSettings": {
									"type": "DelimitedTextWriteSettings",
									"quoteAllText": true,
									"fileExtension": ".csv"
								}
							},
							"enableStaging": false,
							"translator": {
								"type": "TabularTranslator",
								"typeConversion": true,
								"typeConversionSettings": {
									"allowDataTruncation": true,
									"treatBooleanAsNumber": false
								}
							}
						},
						"inputs": [
							{
								"referenceName": "ds_ablob_bajlecblob_src",
								"type": "DatasetReference",
								"parameters": {}
							}
						],
						"outputs": [
							{
								"referenceName": "ds_ablob_bajlecblob_tgt",
								"type": "DatasetReference",
								"parameters": {
									"p_window_end_date": {
										"value": "@pipeline().parameters.p_window_end_date",
										"type": "Expression"
									}
								}
							}
						]
					}
				],
				"policy": {
					"elapsedTimeMetric": {},
					"cancelAfter": {}
				},
				"parameters": {
					"p_window_end_date": {
						"type": "string"
					}
				},
				"folder": {
					"name": "tumblingwindow"
				},
				"annotations": []
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/Movies Clean')]",
			"type": "Microsoft.DataFactory/factories/pipelines",
			"apiVersion": "2018-06-01",
			"properties": {
				"activities": [
					{
						"name": "MoviesCleanFlow",
						"type": "ExecuteDataFlow",
						"dependsOn": [],
						"policy": {
							"timeout": "7.00:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"dataflow": {
								"referenceName": "MoviesCleanFlow",
								"type": "DataFlowReference",
								"parameters": {},
								"datasetParameters": {
									"Movies": {},
									"MoviesClean": {},
									"MoviesByYearSink": {}
								}
							},
							"staging": {},
							"compute": {
								"coreCount": 8,
								"computeType": "General"
							},
							"traceLevel": "Fine"
						}
					}
				],
				"policy": {
					"elapsedTimeMetric": {},
					"cancelAfter": {}
				},
				"folder": {
					"name": "zmy00_Misc"
				},
				"annotations": [],
				"lastPublishTime": "2020-09-20T08:29:19Z"
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/dataflows/MoviesCleanFlow')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/Onprem To Blob')]",
			"type": "Microsoft.DataFactory/factories/pipelines",
			"apiVersion": "2018-06-01",
			"properties": {
				"activities": [
					{
						"name": "Copy data1",
						"type": "Copy",
						"dependsOn": [],
						"policy": {
							"timeout": "7.00:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"source": {
								"type": "SqlServerSource",
								"queryTimeout": "02:00:00",
								"partitionOption": "None"
							},
							"sink": {
								"type": "DelimitedTextSink",
								"storeSettings": {
									"type": "AzureBlobStorageWriteSettings"
								},
								"formatSettings": {
									"type": "DelimitedTextWriteSettings",
									"quoteAllText": true,
									"fileExtension": ".txt"
								}
							},
							"enableStaging": false,
							"translator": {
								"type": "TabularTranslator",
								"typeConversion": true,
								"typeConversionSettings": {
									"allowDataTruncation": true,
									"treatBooleanAsNumber": false
								}
							}
						},
						"inputs": [
							{
								"referenceName": "Onprem_cars_table",
								"type": "DatasetReference",
								"parameters": {}
							}
						],
						"outputs": [
							{
								"referenceName": "Demo_cars_csv",
								"type": "DatasetReference",
								"parameters": {}
							}
						]
					}
				],
				"policy": {
					"elapsedTimeMetric": {},
					"cancelAfter": {}
				},
				"folder": {
					"name": "zmy00_Misc"
				},
				"annotations": [],
				"lastPublishTime": "2020-09-20T08:29:19Z"
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/datasets/Onprem_cars_table')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/PIP_LoadFactSales2')]",
			"type": "Microsoft.DataFactory/factories/pipelines",
			"apiVersion": "2018-06-01",
			"properties": {
				"activities": [
					{
						"name": "DF_LoadFactSales2",
						"type": "ExecuteDataFlow",
						"dependsOn": [],
						"policy": {
							"timeout": "7.00:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"dataflow": {
								"referenceName": "DF_LoadFactSales2",
								"type": "DataFlowReference",
								"parameters": {},
								"datasetParameters": {
									"StagingFact": {},
									"DimCustomer": {},
									"DimProduct": {},
									"LoadFactSales2": {}
								}
							},
							"staging": {},
							"compute": {
								"coreCount": 8,
								"computeType": "General"
							},
							"traceLevel": "Fine"
						}
					}
				],
				"policy": {
					"elapsedTimeMetric": {},
					"cancelAfter": {}
				},
				"folder": {
					"name": "bidesign"
				},
				"annotations": [],
				"lastPublishTime": "2020-09-25T10:38:27Z"
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/dataflows/DF_LoadFactSales2')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/pip_FactScoreDataFlow')]",
			"type": "Microsoft.DataFactory/factories/pipelines",
			"apiVersion": "2018-06-01",
			"properties": {
				"activities": [
					{
						"name": "df_LoadFactScore",
						"type": "ExecuteDataFlow",
						"dependsOn": [],
						"policy": {
							"timeout": "7.00:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"dataflow": {
								"referenceName": "df_LoadFactScore",
								"type": "DataFlowReference",
								"parameters": {},
								"datasetParameters": {
									"StagingScore": {},
									"DimTeam": {},
									"FactScore": {}
								}
							},
							"staging": {},
							"compute": {
								"coreCount": 8,
								"computeType": "General"
							},
							"traceLevel": "Fine"
						}
					}
				],
				"policy": {
					"elapsedTimeMetric": {},
					"cancelAfter": {}
				},
				"folder": {
					"name": "zmy01_IncLoad_SCD"
				},
				"annotations": [],
				"lastPublishTime": "2020-09-20T13:27:03Z"
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/dataflows/df_LoadFactScore')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/pip_Master')]",
			"type": "Microsoft.DataFactory/factories/pipelines",
			"apiVersion": "2018-06-01",
			"properties": {
				"activities": [
					{
						"name": "Execute Pipeline1",
						"type": "ExecutePipeline",
						"dependsOn": [],
						"userProperties": [],
						"typeProperties": {
							"pipeline": {
								"referenceName": "pip_Email",
								"type": "PipelineReference"
							},
							"waitOnCompletion": true,
							"parameters": {}
						}
					},
					{
						"name": "Send Email Success",
						"type": "WebActivity",
						"dependsOn": [
							{
								"activity": "Execute Pipeline1",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"timeout": "7.00:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"url": "https://prod-28.uksouth.logic.azure.com:443/workflows/5a5278aa59d741cd9ab8b9b88f395947/triggers/manual/paths/invoke?api-version=2016-10-01&sp=%2Ftriggers%2Fmanual%2Frun&sv=1.0&sig=uioEqaKZO7rgtq6ZDHYglW6e8PD9WhB6D4ZdQNg3XRM",
							"method": "POST",
							"headers": {},
							"body": {
								"value": "{\n    \"title\": \"PIPELINE FINISHED\",\n    \"message\": \"DEMO PIPELINE RUNNING SUCCESSFULLY\",\n    \"color\": \"Green\",\n    \"dataFactoryName\": \"@{pipeline().DataFactory}\",\n    \"pipelineName\": \"@{pipeline().Pipeline}\",\n    \"pipelineRunId\": \"@{pipeline().RunId}\",\n    \"time\": \"@{utcnow()}\"\n}",
								"type": "Expression"
							}
						}
					},
					{
						"name": "Send Email Failure",
						"type": "WebActivity",
						"dependsOn": [
							{
								"activity": "Execute Pipeline1",
								"dependencyConditions": [
									"Failed"
								]
							}
						],
						"policy": {
							"timeout": "7.00:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"url": "https://prod-28.uksouth.logic.azure.com:443/workflows/5a5278aa59d741cd9ab8b9b88f395947/triggers/manual/paths/invoke?api-version=2016-10-01&sp=%2Ftriggers%2Fmanual%2Frun&sv=1.0&sig=uioEqaKZO7rgtq6ZDHYglW6e8PD9WhB6D4ZdQNg3XRM",
							"method": "POST",
							"headers": {},
							"body": {
								"value": "{\n    \"title\": \"PIPELINE FAILED\",\n    \"message\": \"@{activity('Execute Pipeline1').error.message}\",\n    \"color\": \"Red\",\n    \"dataFactoryName\": \"@{pipeline().DataFactory}\",\n    \"pipelineName\": \"@{pipeline().Pipeline}\",\n    \"pipelineRunId\": \"@{pipeline().RunId}\",\n    \"time\": \"@{utcnow()}\"\n}",
								"type": "Expression"
							}
						}
					}
				],
				"policy": {
					"elapsedTimeMetric": {},
					"cancelAfter": {}
				},
				"folder": {
					"name": "zmy00_Misc"
				},
				"annotations": [],
				"lastPublishTime": "2020-09-20T08:29:19Z"
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/pip_SCD1Team')]",
			"type": "Microsoft.DataFactory/factories/pipelines",
			"apiVersion": "2018-06-01",
			"properties": {
				"activities": [
					{
						"name": "df_LoadDimTeamType1",
						"type": "ExecuteDataFlow",
						"dependsOn": [],
						"policy": {
							"timeout": "7.00:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"dataflow": {
								"referenceName": "df_LoadDimTeamType1_V2",
								"type": "DataFlowReference",
								"parameters": {},
								"datasetParameters": {
									"StageTable": {},
									"DimTable": {},
									"MaxTeamKey": {},
									"InsertSink": {},
									"UpdateSink": {}
								}
							},
							"staging": {},
							"compute": {
								"coreCount": 8,
								"computeType": "General"
							},
							"traceLevel": "Fine"
						}
					}
				],
				"policy": {
					"elapsedTimeMetric": {},
					"cancelAfter": {}
				},
				"folder": {
					"name": "zmy01_IncLoad_SCD"
				},
				"annotations": [],
				"lastPublishTime": "2020-09-25T07:25:56Z"
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/dataflows/df_LoadDimTeamType1_V2')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/pip_SCD2Team')]",
			"type": "Microsoft.DataFactory/factories/pipelines",
			"apiVersion": "2018-06-01",
			"properties": {
				"activities": [
					{
						"name": "df_LoadDimTeamType2",
						"type": "ExecuteDataFlow",
						"dependsOn": [],
						"policy": {
							"timeout": "7.00:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"dataflow": {
								"referenceName": "df_LoadDimTeamType2_V2",
								"type": "DataFlowReference",
								"parameters": {},
								"datasetParameters": {
									"StageTable": {},
									"DimTable": {},
									"MaxTeamKey": {},
									"InsertSink": {},
									"UpdateSink": {}
								}
							},
							"staging": {},
							"compute": {
								"coreCount": 8,
								"computeType": "General"
							},
							"traceLevel": "Fine"
						}
					}
				],
				"policy": {
					"elapsedTimeMetric": {},
					"cancelAfter": {}
				},
				"folder": {
					"name": "zmy01_IncLoad_SCD"
				},
				"annotations": [],
				"lastPublishTime": "2020-09-25T16:17:34Z"
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/dataflows/df_LoadDimTeamType2_V2')]"
			]
		}
	]
}